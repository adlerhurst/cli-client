package main

import (
	"flag"
	"log"
	"time"

	option "github.com/adlerhurst/protoc-gen-go-cli/gen/proto/adlerhurst/cli/v1alpha"
	"github.com/adlerhurst/protoc-gen-go-cli/gen/proto/example"
	"github.com/adlerhurst/protoc-gen-go-cli/types"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type CLI struct {
	name     string
	commands []*Command
}

type Command struct {
	name    string
	methods []*types.Call
}

type Arg struct {
	name string
	subs []types.Arg
	kind protoreflect.Kind
}

func (a *Arg) Name() string {
	return a.name
}

var registry protoregistry.Files

func main() {
	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, file := range plugin.Files {
			if err := registry.RegisterFile(file.Desc); err != nil {
				log.Println("register failed", err)
			}

			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}

		return nil
	})
}

const fileSuffix = "_cli_comment.pb.go"

func generateFile(plugin *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	cli := types.CLI{
		Name: "Eventstore",
		Commands: []*types.Command{
			{
				Name:    "client",
				Service: "ExampleService",
				Calls: []*types.Call{
					{
						Name:      "call",
						ProtoName: "Call",
						Args: []types.Arg{
							types.NewStringArg("useFieldName", "value1"),
							types.NewStringArg("custom", "value2"),
							types.NewMessageArg("nested", map[string]types.Arg{
								"field": types.NewStringArg("field", "value3"),
							}),
							types.NewRepeatedArg("rep_nest", types.NewMessageArg("", map[string]types.Arg{
								"field": types.NewStringArg("field", "value4"),
							})),
							// TODO: created_at
							// TODO: payload
							types.NewEnumArg("wat_string", example.CallRequest_WAT_ICH.Descriptor(), example.CallRequest_WAT_WEISS.String()),
							types.NewEnumArg("wat_int", example.CallRequest_WAT_ICH.Descriptor(), example.CallRequest_WAT_WEISS),
						},
					},
				},
			},
		},
	}

	cli.Generate(plugin, file)
	g := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+fileSuffix, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-cli. DO NOT EDIT.")
	g.P("//", time.Now().Format(time.TimeOnly))
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	f := parseFile(file)
	if len(f.commands) == 0 {
		return nil
	}

	g.P("// cli name: ", f.name)

	for _, cmd := range f.commands {
		g.P("//  ", cmd.name)
		for _, m := range cmd.methods {
			g.P("//    ", m.Name)
			for _, field := range m.Args {
				g.P("//      --", field.Name())
				// for _, sub := range field.subs {
				// 	g.P("//        --", sub.name)
				// 	for _, sub := range sub.subs {
				// 		g.P("//          --", sub.name)
				// 		for _, sub := range sub.subs {
				// 			g.P("//            --", sub.name)
				// 			for _, sub := range sub.subs {
				// 				g.P("//              --", sub.name)
				// 				for _, sub := range sub.subs {
				// 					g.P("//                --", sub.name)
				// 				}
				// 			}
				// 		}
				// 	}
				// }
			}
		}
	}

	// for _, cmd := range f.commands {
	// 	for _, method := range cmd.methods {
	// 		if err := method.Generate(plugin, file); err != nil {
	// 			log.Println(err)
	// 		}
	// 	}
	// }

	return g
}

func parseFile(protoFile *protogen.File) *CLI {
	opts := protoFile.Desc.Options().(*descriptorpb.FileOptions)

	cli := &CLI{
		commands: make([]*Command, 0, len(protoFile.Services)),
		name:     proto.GetExtension(opts, option.E_CliName).(string),
	}

	for _, svc := range protoFile.Services {
		cli.commands = append(cli.commands, parseService(protoFile, svc))
	}

	return cli
}

func parseService(f *protogen.File, svc *protogen.Service) *Command {
	command := &Command{
		methods: make([]*types.Call, 0, len(svc.Methods)),
	}

	opts := svc.Desc.Options().(*descriptorpb.ServiceOptions)
	command.name = proto.GetExtension(opts, option.E_CommandName).(string)
	if command.name == "" {
		command.name = string(svc.Desc.Name())
	}

	for _, method := range svc.Methods {
		command.methods = append(command.methods, parseMethod(f, method))
	}

	return command
}

func parseMethod(f *protogen.File, m *protogen.Method) *types.Call {
	opts := m.Desc.Options().(*descriptorpb.MethodOptions)
	call := &types.Call{
		Name: proto.GetExtension(opts, option.E_CallName).(string),
		Args: parseMessage(m.Input.Desc.FullName()),
	}
	if call.Name == "" {
		call.Name = string(m.Desc.Name())
	}

	return call
}

func parseMessage(msgName protoreflect.FullName) []types.Arg {
	msgDescriptor, err := registry.FindDescriptorByName(msgName)
	if err != nil {
		log.Fatalf("%q not found in registry: %v", msgName, err)
	}
	msg := msgDescriptor.(protoreflect.MessageDescriptor)

	args := make([]types.Arg, 0, msg.Fields().Len())
	for i := 0; i < msg.Fields().Len(); i++ {
		args = append(args, parseField(msg.Fields().Get(i)))
	}
	return args
}

func parseField(f protoreflect.FieldDescriptor) types.Arg {
	arg := &Arg{
		kind: f.Kind(),
	}

	opts := f.Options().(*descriptorpb.FieldOptions)
	arg.name = proto.GetExtension(opts, option.E_ArgName).(string)
	if arg.name == "" {
		arg.name = string(f.JSONName())
	}

	if proto.GetExtension(opts, option.E_IgnoreFields).(bool) {
		return arg
	}

	if f.Message() == nil || f.Message().Fields().Len() == 0 {
		return arg
	}

	for i := 0; i < f.Message().Fields().Len(); i++ {
		sub := f.Message().Fields().Get(i)
		arg.subs = append(arg.subs, parseField(sub))
	}

	return arg
}
